​
### 文献
  - 

### 目录
- [文献](#文献)
- [目录](#目录)
- [定义](#定义)
- [属性代理](#属性代理)
- [反向继承](#反向继承)
- [渲染劫持](#渲染劫持)


### 定义
高阶组件（HOC）是 React 中用于重用组件逻辑的高级技术。 HOC 本身不是 React API 的一部分。 它们是从 React 构思本质中浮现出来的一种模式。

具体来说，高阶组件就是一个没有副作用的纯函数，能够接受一个组件并返回一个新的组件。

理解: 一类特别的函数
  - 参数是函数
  - 返回是函数 
  - 常见的高阶函数:

定时器设置函数
  - 数组的 map()/filter()/reduce()/find()/bind()
  - react-redux 中的 connect 函数

作用: 能实现更加动态, 更加可扩展的功能

缺陷：
- HOC需要在原组件上进行包裹或者嵌套，如果大量使用HOC，将会产生非常多的嵌套，这让调试变得非常困难。
- HOC可以劫持props，在不遵守约定的情况下也可能造成冲突。

实现高阶组件的方法
- 属性代理：高阶组件通过被包裹的React组件来操作props
- 反向继承：高阶组件继承于被包裹的React组件

### 属性代理
```JS
import React,{Component} from 'react';

const MyContainer = (WraooedComponent) => 

  class extends Component {
    render(){
        return <WrappedComponent {...this.props} />
    }
  }
```
我们就可以通过高阶组件来传递props。这种方法即为属性代理

```JS
import React,{Component} from 'react';

class MyComponent extends Component{
    //...
}

export default MyContainer(MyComponent);
```

这样组件就可以一层层地作为参数被调用，原始组件就具备了高阶组件对它的修饰。保持单个组件封装性的同时还保留了易用性。

### 反向继承
另一种构建高阶组件的方法称为反向继承

```JS
import React from 'react';
// 高阶组件函数
const Hoc = WrappedComponent => {
    return class extends WrappedComponent {
      state = {
        num: 1
      };
      componentDidMount() {
        // console.log("didMountHoc");
      }
      handleClick = () => {
        this.setState({
          num: this.state.num + 1
        });
      };
      render() {
        // console.log("renderHoc");
        // 核心代码
        let renderTree = super.render();
        let newProps = {
          ...renderTree.props,
          onClick: this.handleClick
        };
        const newRenderTree = React.cloneElement(
          renderTree,
          newProps,
        );
        console.log(newRenderTree)
        return newRenderTree;
        // return super.render()
      }
    };
};

export default Hoc
```

如上代码。高阶组件返回的组件继承于 WrappedComponent 。因为被动地继承了 WrappedComponent，所有的调用都会反向，这也是种方法的由来。

这种方法与属性代理不太一样。它通过继承WrappedComponent来实现，方法可以通过super来顺序调用。因为依赖于继承机制。HOC的调用顺序和队列是一样的。

在反向继承方法中，高阶组件可以使用 WrappedComponent 引用，这意味着它可以使用 WrappedComponent 的state 、props。生命周期和render方法。但它不能保证完整的子组件树被解析。

### 渲染劫持

渲染劫持就是指的是高阶组件可以控制 WrappedComponent的渲染过程，并渲染各种各样的结果。我们可以在这个过程中在任何React元素输出的结果中读取、增加、修改、删除props，或读取或修改React元素树，或条件显示。又或者用样式包裹元素树

```JS
// 劫持渲染
function hijackHOC(WrappedComponent) {
  return class extends WrappedComponent {
    render() {
      const tree = super.render();
      let newProps = {};
      if (tree && tree.type === 'input') {
        newProps = { value: '渲染被劫持了' };
      }
      const props = Object.assign({}, tree.props, newProps);
      const newTree = React.cloneElement(tree, props, tree.props.children);
      return newTree;
    }
  }
}
// 组合渲染
function styleHOC(WrappedComponent) {
  return class extends WrappedComponent {
    render() {
      return <div>
        <div className="title">{this.props.title}</div>
        {super.render()}
      </div>
    }
  }
}
// 条件渲染
function visibleHOC(WrappedComponent) {
  return class extends Component {
    render() {
      if (this.props.visible === false) return null;
      return <WrappedComponent {...props} />;
    }
  }
}
```

操作props
```JS
function proxyHOC(WrappedComponent) {
  return class extends Component {
    render() {
      const newProps = {
        ...this.props,
        user: 'ConardLi'
      }
      return <WrappedComponent {...newProps} />;
    }
  }
}
```
 控制state

高阶组件可以读取、修改或删除WrappedComponent实例中的state，如果需要的话，也可以增加state。
```JS
function debugHOC(WrappedComponent) {
  return class extends WrappedComponent {
    render() {
      console.log('props', this.props);
      console.log('state', this.state);
      return (
        <div className="debuging">
          {super.render()}
        </div>
      )
    }
  }
}
```
组件命名

当包裹一个高阶组件时，我们失去了原始 WrappedComponent的displayName，而组件名字是方便我们开发与调试的重要属性。

​