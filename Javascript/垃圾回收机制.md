### 文献
  - [文献](https://juejin.cn/post/6981588276356317214)
  - [文献](https://juejin.cn/post/6844904016325902344#heading-4)

### 目录
  - 垃圾回收机制/内存泄漏
    - 垃圾回收机制
    - V8对GC的垃圾回收机制优化：分代式垃圾回收
    - 内存泄漏

### 垃圾回收机制/内存泄漏
#### 垃圾回收机制
  - 标记清除：当前采用的垃圾收集策略
    - 工作原理：当变量进入环境时(例如在函数中声明一个变量)，将这个变量标记为“进入环境”，当变量离开环境时，则将其标记为“离开环境”。标记“离开环境”的就回收内存。
    - 主要将GC的垃圾回收过程分为两个阶段
      1. 标记阶段：把所有活动对象做上标记。
      2. 清除阶段：把没有标记（也就是非活动对象）销毁
    - 工作流程：
      1. 垃圾收集器会在运行的时候会给存储在内存中的所有变量都加上标记。
      2. 去掉环境中的变量以及被环境中的变量引用的变量的标记。
      3. 那些还存在标记的变量被视为准备删除的变量。
      4. 最后垃圾收集器会执行最后一步内存清除的工作，销毁那些带标记的值并回收它们所占用的内存空间。
    - 分配策略
      1. First-fit，找到大于等于 size 的块立即返回
      2. Best-fit，遍历整个空闲列表，返回大于等于 size 的最小分块
      3. Worst-fit，遍历整个空闲列表，找到最大的分块，然后切成两部分，一部分 size 大小，并将该部分返回
    - 标记清除优点：标记清除算法的优点只有一个，那就是实现比较简单，打标记也无非打与不打两种情况，这使得一位二进制位（0和1）就可以为其标记，非常简单
    - 标记清除缺点
      1. 内存碎片化，空闲内存块是不连续的，容易出现很多空闲内存块，还可能会出现分配所需内存过大的对象时找不到合适的块
      2. 分配速度慢，因为即便是使用 First-fit 策略，其操作仍是一个 O(n) 的操作，最坏情况是每次都要遍历到最后，同时因为碎片化，大对象的分配效率会更慢
    - 归根结底，标记清除算法的缺点在于清除之后剩余的对象位置不变而导致的空闲内存不连续，所以只要解决这一点，两个缺点都可以完美解决了

  - 引用计数略：被废弃的垃圾收集策略（主流浏览器废弃，所以不扩展了）
#### V8对GC的垃圾回收机制优化：分代式垃圾回收
  > V8 的垃圾回收策略主要基于分代式垃圾回收机制，将**堆内存**分为**新生代**和**老生代**两区域，采用不同的垃圾回收器也就是不同的策略管理垃圾回收
  > 新生代的对象为存活时间较短的对象，简单来说就是新产生的对象，通常只支持 1～8M 的容量，而老生代的对象为存活事件较长或常驻内存的对象，简单来说就是经历过新生代垃圾回收后还存活下来的对象，容量通常比较大
  - 何为新生代/老生代
    1. 新生代的对象为存活时间较短的对象，简单来说就是新产生的对象，通常只支持 1～8M 的容量
    2. 老生代的对象为存活事件较长或常驻内存的对象，简单来说就是经历过新生代垃圾回收后还存活下来的对象，容量通常比较大
  - 回收机制
    1. 如图
      - ![图片](/Users/futurngazer/Desktop/2024面试题汇总/Javascript/images/image.png)
    2. 新生代垃圾回收（Scavenge 算法，在 Scavenge算法 的具体实现中，主要采用了一种复制式的方法即 Cheney算法）
      - Cheney算法 中将堆内存一分为二，一个是处于使用状态的空间我们暂且称之为 **使用区**，一个是处于闲置状态的空间我们称之为 **空闲区**
      - 新加入的对象都会存放到使用区，当使用区快被写满时，就需要执行一次垃圾清理操作
      - 当开始进行垃圾回收时，新生代垃圾回收器会对使用区中的活动对象做标记，标记完成之后将使用区的活动对象复制进空闲区并进行排序，随后进入垃圾清理阶段，即将非活动对象占用的空间清理掉。最后进行角色互换，把原来的使用区变成空闲区，把原来的空闲区变成使用区
      - 当一个对象经过多次复制后依然存活，它将会被认为是生命周期较长的对象，随后会被移动到老生代中，采用老生代的垃圾回收策略进行管理
      - 另外还有一种情况，如果复制一个对象到空闲区时，空闲区空间占用超过了 25%，那么这个对象会被直接晋升到老生代空间中，设置为 25% 的比例的原因是，当完成 Scavenge 回收后，空闲区将翻转成使用区，继续进行对象内存的分配，若占比过大，将会影响后续内存分配
    3. 老生代垃圾回收
      - 老生代垃圾回收器来管理老生代垃圾回收执行，它的整个流程就采用的就是上文所说的标记清除算法
  
  - 并行回收(Parallel) 
    - ![图片](/Users/futurngazer/Desktop/2024面试题汇总/Javascript/images/image2.png)
    - **全停顿**（Stop-The-World）: JavaScript 是一门单线程的语言，它是运行在主线程上的，那在进行垃圾回收时就会阻塞 **JavaScript** 脚本的执行，需等待垃圾回收完毕后再恢复脚本执行，我们把这种行为叫做 **全停顿**
    - 比如一次 GC 需要 60ms ，那我们的应用逻辑就得暂停 60ms ，假如一次 GC 的时间过长，对用户来说就可能造成页面卡顿等问题
    - 所谓并行，也就是同时的意思，它指的是垃圾回收器在主线程上执行的过程中，开启多个辅助线程，同时执行同样的回收工作
    - 简单来说，使用并行回收，假如本来是主线程一个人干活，它一个人需要 3 秒，现在叫上了 2 个辅助线程和主线程一块干活，那三个人一块干一个人干 1 秒就完事了，但是由于多人协同办公，所以需要加上一部分多人协同（同步开销）的时间我们算 0.5 秒好了，也就是说，采用并行策略后，本来要 3 秒的活现在 1.5 秒就可以干完了
    - 不过虽然 1.5 秒就可以干完了，时间也大大缩小了，但是这 1.5 秒内，主线程还是需要让出来的，也正是因为主线程还是需要让出来，这个过程内存是静态的，不需要考虑内存中对象的引用关系改变，只需要考虑协同
    - **新生代**对象空间就采用**并行策略**，在执行垃圾回收的过程中，会启动了多个线程来负责新生代中的垃圾清理操作，这些线程同时将对象空间中的数据移动到空闲区域，这个过程中由于数据地址会发生改变，所以还需要同步更新引用这些对象的指针，此即并行回收
    - ......

#### 内存泄漏
  > 内存泄漏（Memory Leak）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果
  - 全局变量的生命周期直至浏览器卸载页面才会结束，也就是说全局变量不会被当成垃圾回收。
  - 被遗忘的定时器和回调函数（闭包）
  - console保存大量数据在内存中
  - 一般是堆区内存泄漏，栈区不会泄漏