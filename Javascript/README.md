## 

## 参考文献

## 目录
  - JavaScript 概念
  - 基础（数据类型/变量提升/解析机制/作用域/）
  - 事件流
  - 事件循环
  - this指向
    - 默认绑定(非严格模式下this指向全局对象, 严格模式下this会绑定到undefined)
    - 隐式绑定(当函数引用有上下文对象时, 如 obj.foo()的调用方式, foo内的this指向obj)
    - 隐式绑定的隐式丢失问题
    - 显式绑定
    - 显式绑定的其它用法
    - new 绑定
    - 箭头函数绑定
  - 原型链、继承(理解new做了什么)
  - 闭包&**函数柯里化**
  - 垃圾回收机制/内存泄漏
  - 扩展（常用的一些api）
    - 判断数据类型
    - Object.defineProperty 和 Proxy

## 内容
### 概念
  > JavaScript 是一种**单线程**的脚本编程语言

### 基础
  - 数据类型
    - 值类型(基本类型)**存放在栈内存中**：字符串（String）、数字(Number)、布尔(Boolean)、空（Null）、未定义（Undefined）、Symbol
    - 引用数据类型（对象类型）**存放在堆内存中**：对象(Object)、数组(Array)、函数(Function)，还有两个特殊的对象：正则（RegExp）和日期（Date）
    - 在栈内存中变量保存的是一个**指针**，指向对应在堆内存中的**地址**
    - 因为**堆栈**这个概念，导致出现了深拷贝浅拷贝这个问题
      - 直接传递引用类性值的时候，传递的只是引用，二者指向同一块内存，所以修改其中一个，必然会引起另一个变量的变化。 在日常的使用中，我们把对象赋值给一个变量时，通常希望得到的是一个跟原对象无关的副本，修改新的变量不影响原对象，因此就有了浅拷贝和深拷贝。 
  - 深拷贝、浅拷贝
    - 浅拷贝
      - 数组map
      - Object.assign
      - ...
      ``` Javascript
        var obj1 = {a:1,b:2,c:{c1:3}}
        var obj2 = Object.assign({},obj1)
        obj2.a = 99
        // 打印结果 obj1 =  {a:1,b:2,c:{c1:3}}
        // 打印结果 obj2 =  {a:99,b:2,c:{c1:3}}
        obj2.c.c1 = 99
        // 打印结果 obj1 =  {a:1,b:2,c:{c1:99}}
        // 打印结果 obj2 =  {a:99,b:2,c:{c1:99}}
        // 浅拷贝就是只拷贝了第一层分别指向不同的堆内存
      ```
    - 深拷贝
      - 根据上面的例子，那么深拷贝的目的就是完全复制一个堆内存，而不是只复制第一层
      - 数组的大部分方法属于浅拷贝或者就不是拷贝
      - 常用的JSON.parse/JSON.stringify互转一次（以后涉及底层APi的时候不能用这个，存在丢失隐性对象的风险）
      - 或者借用插件或者自己封装
  - 变量提升、函数提升、浏览器解析变量的机制
    > 查看Javascript解析机制.md
    1. 当浏览器加载html页面的时候，首先会提供一个全局JS代码执行的环境(全局作用域)
    2. 预解析（变量提升，浏览器的加载机制）
    3. 注意：对于**变量**只是进行了**变量提前声明**，而**函数**是**提前声明**并且**定义**
    4. 预解析只发生在当前的作用域(全局作用域/局部作用域)下，例如：开始只对window下的进行预解释，只有函数执行的时候才会对函数中的进行预解析
  - 作用域
    > 作用域链是由于js的变量都是对象的属性，而该对象可能又是其它对象的属性，而所有的对象都是window对象的属性，所以这些对象的关系可以看作是一条链
    > 作用域就是变量与函数的可访问范围，即作用域控制着变量与函数的可见性和生命周期。在JavaScript中，变量的作用域有全局作用域和局部作用域两种。
    - 全局作用域
      - 最外层函数和在最外层函数外面定义的变量
      - 没有通过关键字"var"声明的变量。
      - 浏览器中，window对象的属性
    - 局部作用域：函数作用域（Function scope），所有的变量和函数只能在作用域内部使用
    - 理解上下文和作用域
      > 函数的每次调用都会有与之紧密相连的作用域和上下文,从本质上说,作用域其实是基于函数的,而上下文是基于对象的,也就是说作用域是涉及到它所被调用函数中的变量访问,而调用方法和访问属性又存在着不同的调用场景(4种调用场景,函数调用,方法调用,构造器函数调用,call(),apply()间接调用),而上下文始终是this所代表的值,它是拥有控制当前执行代码的对象的引用

### 事件流
  - 概念：事件流包括三个阶段：事件捕获阶段、处于目标阶段、事件冒泡阶段。
    - 首先发生的事件捕获，为截获事件提供机会。然后是实际的目标接受事件。最后一个阶段是时间冒泡阶段，可以在这个阶段对事件做出响应。以前面的例子，则会按下图顺序触发事件。
    - 在DOM事件流中，事件的目标在捕获阶段不会接受到事件。这意味着在捕获阶段，事件从document到p后就定停止了。
    - 下一个阶段是处于目标阶段，于是事件在p上发生，并在事件处理中被看成冒泡阶段的一部分。然后，冒泡阶段发生，事件又传播回document。

### 事件循环
  > 查看 事件循环.md
### this指向
  > 查看 this指向.md
### 原型链、继承
  > 查看 原型链&继承.md

### 闭包&&函数柯里化
  > 查看 闭包&函数柯里化.md

### 垃圾回收机制/内存泄漏
  > 查看 垃圾回收机制.md

### 扩展
  - 查看 javascriptApi扩展