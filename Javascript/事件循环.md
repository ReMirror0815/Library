### 事件循环
  > javascript是一门**单线程**的非阻塞的脚本语言。
  > javascript引擎就是通过event loop（事件循环）来实现“非阻塞”的
  - 总结一下
    - 同步任务都在主线程上执行，形成一个执行栈
    - 主线程之外，还存在一个事件队列。只要异步任务有了运行结果，就在事件队列之中放置一个事件。
    - 一旦执行栈中的所有同步任务执行完毕，系统就会读取事件队列,将队列中的事件放到执行栈中依次执行
    - 主线程从任务队列中读取事件，这个过程是循环不断的，整个过程就是Event Loop (事件循环)
  - 在事件队列中任务被分为两种：
    - 宏任务
      1. setTimeout
      2. setInterval
      3. ...
    - 微任务
      1. Promise
      2. Object.observe
      3. MutationObserver
      4. ...
  - 执行顺序： 
    - 当前执行栈执行完毕时会立刻先处理所有微任务队列中的事件，然后再去宏任务队列中取出一个事件。
    - 同一次事件循环中，微任务永远在宏任务之前执行。
      1. 宏任务优先级较低，若当前执行的是微任务，且微任务队列中任然有task，他会将其中的微任务全部执行完成
      2. 当没有微任务时，才去执行宏任务中的第一条。一旦宏任务执行完，发现有微任务，将继续执行微任务，遵循 1
  - [参考这里, 博客下面有习题，一定要自己做明白并且理解](https://blog.csdn.net/halations/article/details/109486109?spm=1001.2014.3001.5501)

### 经典例子
1. 为什么这份代码它不按照我的意思走？为啥不是输出 1 2 3
```JS
for (var i = 0; i < 3; i++) {
  setTimeout(() => {
    console.log(i);
  }, 1000);
}
// console:
// 3
// 3
// 3
```
2. 为什么这份代码它也不按照我的意思走？为啥不是输出 jsliang？
```JS
let name;
setTimeout(() => {
  name = 'Mirror';
  console.log(name);
}, 1000);

if (name) {
  name = 'jsliang';
  console.log(name);
}
// console: 'Mirror'
```
> 原因：定时器为宏任务，遇到宏任务时，宏任务放入队列，先执行同步任务，同步任务全部执行完成，再执行宏任务