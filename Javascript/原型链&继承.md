### 文献
 - [文献](https://obkoro1.com/web_accumulate/accumulate/JS/JS%E5%9F%BA%E7%A1%80-%E7%BB%A7%E6%89%BF.html#%E4%BD%95%E4%B8%BA%E7%BB%A7%E6%89%BF%EF%BC%9F)

### 目录
  - 理解new做了什么
  - 继承
    - 原型链继承(new)
    - 借用构造函数继承(call)
    - 组合继承(call+new)
    - 原型式继承(Object.create())
    - 寄生组合式继承(call+寄生式封装)
    - ES6 extends继承
  - 原型链
    - prototype
    - __proto__
    - 原型链是什么
    - 原型链用来做什么？


### 继承
  > 继承是一个类(或者多个类)从另一个类获取方法和属性的过程。
  > 复制父类的属性和方法来重写子类原型对象

#### 理解new做了什么
  1. 创建一个全新的对象。
  2. 这个新对象的原型(__proto__)指向函数的prototype对象。
  3. 执行函数，函数的this会绑定在新创建的对象上。
  4. 如果函数没有返回其他对象(包括数组、函数、日期对象等)，那么会自动返回这个新对象。
  5. 返回的那个对象为构造函数的实例。

#### 原型链继承(new)
  ```Javascript
  function fatherFn() {
    this.some = '父类的this属性';
  }
  fatherFn.prototype.fatherFnSome =  '父类原型对象的属性或者方法';
  // 子类
  function sonFn() {
    this.obkoro1 = '子类的this属性';
  }
  // 核心步骤：重写子类的原型对象
  sonFn.prototype = new fatherFn(); // 将fatherFn的实例赋值给sonFn的prototype
  sonFn.prototype.sonFnSome = '子类原型对象的属性或者方法' // 子类的属性/方法声明在后面,避免被覆盖
  // 实例化子类
  const sonFnInstance = new sonFn();
  console.log('子类的实例：', sonFnInstance);
  // fatherFn通过this声明的属性/方法都会绑定在new期间创建的新对象上。
  // 新对象的原型是father.prototype,通过原型链的属性查找到father.prototype的属性和方法。
  ```
  - 原型链继承的缺点
    1. 父类使用this声明的属性被所有实例共享
       1. 实例化的父类(sonFn.prototype = new fatherFn())是一次性赋值到子类实例的原型(sonFn.prototype)上，它会将父类通过this声明的属性也在赋值到sonFn.prototype上
    2. 创建子类实例时，无法向父类构造函数传参，不够灵活
#### 借用构造函数继承(call)
  ```Javascript
   function fatherFn(...arr) {
    this.some = '父类的this属性';
    this.params = arr // 父类的参数
  }
  fatherFn.prototype.fatherFnSome = '父类原型对象的属性或者方法';
  function sonFn(fatherParams, ...sonParams) {
    fatherFn.call(this, ...fatherParams); // 核心步骤: 将fatherFn的this指向sonFn的this对象上
    this.obkoro1 = '子类的this属性';
    this.sonParams = sonParams; // 子类的参数
  }
  sonFn.prototype.sonFnSome = '子类原型对象的属性或者方法'
  let fatherParamsArr = ['父类的参数1', '父类的参数2']
  let sonParamsArr = ['子类的参数1', '子类的参数2']
  const sonFnInstance = new sonFn(fatherParamsArr, ...sonParamsArr); // 实例化子类
  console.log('借用构造函数子类实例', sonFnInstance)
  ```
  - 优点：
    1. 可以向父类传递参数
    2. 解决了原型链继承中：父类属性使用this声明的属性会在所有实例共享的问题。
  - 缺点：
    1. 只能继承父类通过this声明的属性/方法，不能继承父类prototype上的属性/方法。
    2. 父类方法无法复用：因为无法继承父类的prototype，所以每次子类实例化都要执行父类函数，重新声明父类this里所定义的方法，因此方法无法复用。

#### 原型式继承(Object.create())
  - 优点： 兼容性好，最简单的对象继承。
  - 缺点：
    1. 因为旧对象(oldObj)是实例对象(newObj)的原型，多个实例共享被继承对象的属性，存在篡改的可能。
    2. 无法传参

#### 组合继承(call+new)
  ```Javascript
    function fatherFn(...arr) {
      this.some = '父类的this属性';
      this.params = arr // 父类的参数
    }
    fatherFn.prototype.fatherFnSome = '父类原型对象的属性或者方法';
    function sonFn() {
      fatherFn.call(this, '借用构造继承', '第二次调用'); // 借用构造继承: 继承父类通过this声明属性和方法至子类实例的属性上
      this.obkoro1 = '子类的this属性';
    }
    sonFn.prototype = new fatherFn('原型链继承', '第一次调用'); // 原型链继承: 将`this`和`prototype`声明的属性/方法继承至子类的`prototype`上
    sonFn.prototype.sonFnSome = '子类原型对象的属性或者方法'
    const sonFnInstance = new sonFn();
    console.log('组合继承子类实例', sonFnInstance)
  ```
  - 优点：
    1. 完整继承(又不是不能用)，解决了：
    2. 父类通过this声明属性/方法被子类实例共享的问题(原型链继承的问题) 每次实例化子类将重新初始化父类通过this声明的属性，实例根据原型链查找规则，每次都会
    3. 父类通过prototype声明的属性/方法无法继承的问题(借用构造函数的问题)。
  - 缺点：
    1. 两次调用父类函数(new fatherFn()和fatherFn.call(this))，造成一定的性能损耗。
    2. 因调用两次父类,导致父类通过this声明的属性/方法，生成两份的问题。
    3. 原型链上下文丢失：子类和父类通过prototype声明的属性/方法都存在于子类的prototype上
#### 寄生组合式继承(call+寄生式封装)
  - 原理
    1. 使用借用构造函数(call)来继承父类this声明的属性/方法
    2. 通过寄生式封装函数设置父类prototype为子类prototype的原型来继承父类的prototype声明的属性/方法。
  ```Javascript
  function fatherFn(...arr) {
    this.some = '父类的this属性';
    this.params = arr // 父类的参数
  }
  fatherFn.prototype.fatherFnSome = '父类原型对象的属性或者方法';
  function sonFn() {
    fatherFn.call(this, '借用构造继承'); // 核心1 借用构造继承: 继承父类通过this声明属性和方法至子类实例的属性上
    this.obkoro1 = '子类的this属性';
  }
  // 核心2 寄生式继承：封装了son.prototype对象原型式继承father.prototype的过程，并且增强了传入的对象。
  function inheritPrototype(son, father) {
    const fatherFnPrototype = Object.create(father.prototype); // 原型式继承：浅拷贝father.prototype对象 father.prototype为新对象的原型
    son.prototype = fatherFnPrototype; // 设置father.prototype为son.prototype的原型
    son.prototype.constructor = son; // 修正constructor 指向
  }
  inheritPrototype(sonFn, fatherFn)
  sonFn.prototype.sonFnSome = '子类原型对象的属性或者方法'
  const sonFnInstance = new sonFn();
  console.log('寄生组合式继承子类实例', sonFnInstance)
  ```
  - 寄生组合式继承相对于组合继承有如下优点：
    1. 只调用一次父类fatherFn构造函数。
    2. 避免在子类prototype上创建不必要多余的属性。
    3. 使用原型式继承父类的prototype，保持了原型链上下文不变。
    4. 子类的prototype只有子类通过prototype声明的属性/方法和父类prototype上的属性/方法泾渭分明。

#### ES6 extends继承
  > ES6继承的原理跟寄生组合式继承是一样的
  - ES5、ES6的继承差异
    1. ES5的继承实质上是先创建子类的实例对象，再将父类的方法添加到this上。
    2. ES6的继承是先创建父类的实例对象this，再用子类的构造函数修改this。
    3. 因为子类没有自己的this对象，所以必须先调用父类的super()方法。
  - 详细请查看ES6的 class、constructor、this


### 原型链
#### prototype
  - 只有函数有prototype属性
  - 除Object，obj是一个全局对象，也是一个构造函数，以及其他基本类型的全局对象也都是构造函数
  ```Javascript
    let a = {}
    let b = function () { }
    console.log(a.prototype) // undefined
    console.log(b.prototype) // { constructor: function(){...} }
  ```
  - 为什么只有函数有prototype属性
    - JS通过new来生成对象，但是仅靠构造函数，每次生成的对象都不一样。
    - 有时候需要在两个对象之间共享属性，由于JS在设计之初没有类的概念，所以JS使用函数的prototype来处理这部分需要被共享的属性，通过函数的prototype来模拟类：
    - 当创建一个函数时，JS会自动为函数添加prototype属性，值是一个有constructor的对象
#### __proto__
  - 不要再使用__proto__
    1. __proto__属性没有写入 ES6 的正文，而是写入了附录。
    2. 原因是它本质上是一个内部属性，而不是一个正式的对外的 API，只是由于浏览器广泛支持，才被加入了 ES6。
    3. 标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。
    4. 所以无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，应该使用：Object.getPrototypeOf(target)（读操作）、Object.setPrototypeOf(target)（写操作）、Object.create(target)（生成操作）代替
#### 原型链是什么
```Javascript
  function foo() { }
  const newObj = new foo() // 构造调用foo 返回一个新对象
  const newObj__proto__ = Object.getPrototypeOf(newObj) // 获取newObj的原型对象
  newObj__proto__ === foo.prototype // true 验证newObj的原型指向foo
  const foo__proto__ = Object.getPrototypeOf(foo.prototype) // 获取foo.prototype的原型
  foo__proto__ === Object.prototype // true foo.prototype的原型是Object.prototype
  // 如果用以前的语法，从`newObj`查找`foo`的原型，是这样的：
  newObj.__proto__.__proto__ // 这种关系就是原型链
```
 - 可以用以下三句话来理解原型链：
  1. 每个对象都拥有一个原型对象: newObj的原型是foo.prototype。
  2. 对象的原型可能也是继承其他原型对象的: foo.prototype也有它的原型Object.prototype。
  3. 一层一层的，以此类推，这种关系就是原型链。

- 一个对象是否在另一个对象的原型链上
  1. 如果一个对象存在另一个对象的原型链上，我们可以说：它们是继承关系。

- 判断方式有两种，但都是根据构造函数的prototype是否在原型链上来判断的：
  1. instanceof:object instanceof constructor
  2. isPrototypeOf:prototypeObj.isPrototypeOf(object)

- 原型链的终点: Object.prototype

#### 原型链用来做什么？
  > 如果试图访问对象(实例instance)的某个属性,会首先在对象内部寻找该属性,直至找不到,然后才在该对象的原型(instance.prototype)里去找这个属性，以此类推